(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{275:function(t,v,_){"use strict";_.r(v);var s=_(28),i=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"this使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this使用"}},[t._v("#")]),t._v(" this使用")]),t._v(" "),_("p",[t._v("http://www.cnblogs.com/front-Thinking/p/4364337.html")]),t._v(" "),_("p",[t._v("this跟函数在哪里定义没有半毛钱关系，函数在哪里调用才决定了this到底引用的是啥。")]),t._v(" "),_("p",[t._v("也就是说this跟函数的定义没关系，跟函数的执行有大大的关系。所以，记住，“函数在哪里调用才决定了this到底引用的是啥”。")]),t._v(" "),_("p",[t._v("学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域，抛开以前错误的假设和理解。")]),t._v(" "),_("p",[t._v("之前我们说过this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。")]),t._v(" "),_("p",[t._v("this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。（调用位置：就是函数在代码中被调用的位置，而不是声明的位置）")]),t._v(" "),_("p",[t._v("当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this就是这个记录的一个属性，会在函数执行的过程中用到。")]),t._v(" "),_("p",[t._v("判断this")]),t._v(" "),_("p",[t._v("现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断：")]),t._v(" "),_("p",[t._v("1.函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。")]),t._v(" "),_("p",[t._v("var bar = new foo();")]),t._v(" "),_("p",[t._v("2.函数是否通过call、apply（显示绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。")]),t._v(" "),_("p",[t._v("var bar = foo.call(obj2)")]),t._v(" "),_("p",[t._v("3.函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。")]),t._v(" "),_("p",[t._v("var bar = obj1.foo();")]),t._v(" "),_("p",[t._v("4.如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined,否则绑定到全局对象。")]),t._v(" "),_("p",[t._v("var bar = foo();")]),t._v(" "),_("p",[t._v("就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白this的绑定原理了。")]),t._v(" "),_("p",[t._v("不过，凡事总有例外。")]),t._v(" "),_("p",[t._v("this使用总结+构造函数扩展+箭头函数：https://cisy.me/this/")])])}),[],!1,null,null,null);v.default=i.exports}}]);